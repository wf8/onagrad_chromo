#!/usr/bin/rb

#base_dir = ""
sample_freq = 1
fixed_tree = FALSE
num_tree_samples = 100

# set my move index
mvi = 1
mni = 1

# read in trees
if (fixed_tree) {
   
    # use only the MAP tree
    psi <- readTrees(base_dir + "data/onagraceae_final_map_trimmed.tree")[1]

} else {

    # use the posterior distribution of trees
    trees <- readTrees(base_dir + "data/combined_trimmed.trees")
        
    # read in the MAP tree to summarize ancestral states on
    psi <- readTrees(base_dir + "data/onagraceae_final_map_trimmed.tree")[1]

}

# read in selfing data
data <- readCharacterDataDelimited(base_dir + "data/selfing_data_complete.csv", stateLabels=2, type="NaturalNumbers", delimiter=",", headers=TRUE)

# add unobserved hidden state
data_exp <- data.expandCharacters( 2 )


# expected num species at time t under constant birth-death is
# E(N_t) = N_0 e^{rt}
# therefore net diversification r is
# r = ( ln N_t - ln N_0 ) / t
# we use r as the mean for the speciation prior
taxa <- psi.taxa()
rate_mean <- ln( ln( 650 / 2.0 ) / psi.rootAge() )
rate_sd <- 2.0

# speciation and extinction rates for each of the 4 states
# drawn from log normal distributions
for (i in 1:4) {
    
    log_speciation[i] ~ dnNormal(mean=rate_mean, sd=rate_sd)
    moves[mvi++] = mvSlide(log_speciation[i], delta=2.0, weight=4)
    moves[mvi++] = mvSlide(log_speciation[i], delta=0.5, weight=4)
    moves[mvi++] = mvSlide(log_speciation[i], delta=0.01, weight=4)
    
    log_extinction[i] ~ dnNormal(mean=rate_mean, sd=rate_sd)
    moves[mvi++] = mvSlide(log_extinction[i], delta=2.0, weight=4)
    moves[mvi++] = mvSlide(log_extinction[i], delta=0.5, weight=4)
    moves[mvi++] = mvSlide(log_extinction[i], delta=0.01, weight=4)
    
    up_down_scale_mv[i] = mvUpDownScale(lambda=0.5, weight=8)
    up_down_scale_mv[i].addVariable( log_speciation[i], TRUE )
    up_down_scale_mv[i].addVariable( log_extinction[i], TRUE )
    moves[mvi++] = up_down_scale_mv[i]
    
    up_down_scale_mv2[i] = mvUpDownScale(lambda=2.0, weight=8)
    up_down_scale_mv2[i].addVariable( log_speciation[i], TRUE )
    up_down_scale_mv2[i].addVariable( log_extinction[i], TRUE )
    moves[mvi++] = up_down_scale_mv2[i]

    speciation[i] := exp( log_speciation[i] )
    extinction[i] := exp( log_extinction[i] )

}

# some reasonable starting values from previous analyses
log_speciation[1].setValue(ln(0.2))
log_speciation[2].setValue(ln(0.15))
log_speciation[3].setValue(ln(3.0))
log_speciation[4].setValue(ln(0.9))

log_extinction[1].setValue(ln(0.5))
log_extinction[2].setValue(ln(0.05))
log_extinction[3].setValue(ln(3.0))
log_extinction[4].setValue(ln(0.3))

diversification := speciation - extinction

# rate_matrix = [0A, 1A, 0B, 1B]
divers_0A := diversification[1]
divers_1A := diversification[2]
divers_0B := diversification[3]
divers_1B := diversification[4]

# transition rates among states
num_events ~ dnUniform(1, 1000)
num_events.setValue(80.0)
moves[mvi++] = mvScale(num_events, lambda=20, weight=3)
moves[mvi++] = mvScale(num_events, lambda=2, weight=3)
rate_pr := psi.treeLength() / num_events

# between observed states
rate_01 <- 0.0 # no secondary gain of incompatibility
rate_10 ~ dnExponential( rate_pr )
rate_10.setValue(0.3)
Q := [rate_01, rate_10]

# between hidden states
rate_AB ~ dnExponential( rate_pr )
rate_AB.setValue(0.002)
rate_BA ~ dnExponential( rate_pr )
rate_BA.setValue(0.4)
R := [rate_AB, rate_BA]

# the rate matrix for the combined observed and hidden states 
rate_matrix := fnHiddenStateRateMatrix(Q, R, rescaled=false)
    
moves[mvi++] = mvScale(rate_10, lambda=1.0, weight=4)
moves[mvi++] = mvScale(rate_AB, lambda=1.0, weight=4)
moves[mvi++] = mvScale(rate_BA, lambda=1.0, weight=4)
moves[mvi++] = mvScale(rate_10, lambda=0.1, weight=4)
moves[mvi++] = mvScale(rate_AB, lambda=0.1, weight=4)
moves[mvi++] = mvScale(rate_BA, lambda=0.1, weight=4)


# root state frequencies 
root_states <- simplex( [0,1,0,1] ) # condition on starting in 1A or 1B


# rho is the probability of sampling species at the present
rho <- psi.ntips()/650

# character dependent birth death process
if (fixed_tree) {

    timetree ~ dnCDBDP( rootAge           = psi.rootAge(),
                        speciationRates   = speciation,
                        extinctionRates   = extinction, 
                        Q                 = rate_matrix, 
                        delta             = 1.0,
                        pi                = root_states,
                        rho               = rho,
                        condition         = "survival",
                        taxa              = taxa )

    #clamp the model with the observed tree and data
    timetree.clamp( psi )
    timetree.clampCharData( data_exp )

} else {
    
    timetree[1] ~ dnCDBDP( rootAge        = psi.rootAge(),
                        speciationRates   = speciation,
                        extinctionRates   = extinction, 
                        Q                 = rate_matrix, 
                        delta             = 1.0,
                        pi                = root_states,
                        rho               = rho,
                        condition         = "survival",
                        taxa              = taxa )

    #clamp the model with the observed tree and data
    timetree[1].clamp( psi )
    timetree[1].clampCharData( data_exp )
    
    for (i in 1:num_tree_samples) {

        j ~ dnUniformInteger(1, trees.size())
        timetree[i + 1] ~ dnCDBDP( rootAge    = trees[j].rootAge(),
                            speciationRates   = speciation,
                            extinctionRates   = extinction, 
                            Q                 = rate_matrix, 
                            delta             = 1.0,
                            pi                = root_states,
                            rho               = rho,
                            condition         = "survival",
                            taxa              = taxa )

        #clamp the model with the observed tree and data
        timetree[i + 1].clamp( trees[j] )
        timetree[i + 1].clampCharData( data_exp )

    }
}

#############
# The Model #
#############


### workspace model wrapper ###
mymodel = model(timetree)

# monitors
monitors[mni++] = mnScreen(printgen=sample_freq, speciation)
monitors[mni++] = mnModel(filename=base_dir + "output/selfing" + rep + ".log", printgen=sample_freq)
if (fixed_tree) {
    monitors[mni++] = mnStochasticCharacterMap(cdbdp=timetree, printgen=sample_freq, filename=base_dir + "output/stochastic_selfing" + rep + ".log", include_simmap=true)
} else {
    monitors[mni++] = mnStochasticCharacterMap(cdbdp=timetree[1], printgen=sample_freq, filename=base_dir + "output/stochastic_selfing" + rep + ".log", include_simmap=true)
}

################
# The Analysis #
################

### workspace mcmc
mymcmc = mcmc(mymodel, monitors, moves)

### run the MCMC
mymcmc.run(generations=500)

q()

