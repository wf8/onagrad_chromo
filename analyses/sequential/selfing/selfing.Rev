#!/usr/bin/rb

#base_dir = ""
sample_freq = 1
fixed_tree = FALSE
num_tree_samples = 100

# set my move index
mvi = 1
mni = 1

# read in data
if (fixed_tree) {
   
    # use only the MAP tree
    psi <- readTrees(base_dir + "data/onagraceae_final_map_trimmed.tree")[1]

} else {

    # use the posterior distribution of trees
    trees <- readTrees(base_dir + "data/combined_trimmed.trees")
        
    # read in the MAP tree to summarize ancestral states on
    psi <- readTrees(base_dir + "data/onagraceae_final_map_trimmed.tree")[1]

}
data <- readCharacterDataDelimited(base_dir + "data/selfing_data_complete.csv", stateLabels=2, type="NaturalNumbers", delimiter=",", headers=TRUE)

# add unobserved hidden state
data_exp <- data.expandCharacters( 2 )


# expected num species at time t under constant birth-death is
# E(N_t) = N_0 e^{rt}
# therefore net diversification r is
# r = ( ln N_t - ln N_0 ) / t
# we use r as the mean for the speciation prior
taxa <- psi.taxa()
#speciation_mean <- ln( taxa.size() ) / psi.rootAge()
speciation_mean <- ln( 650 ) / psi.rootAge()
speciation_pr <- 1 / speciation_mean

#base_speciation ~ dnExponential( speciation_pr )
#moves[mvi++] = mvSlide(base_speciation, delta=5.0, weight=4)
#moves[mvi++] = mvSlide(base_speciation, delta=1.0, weight=4)
#moves[mvi++] = mvSlide(base_speciation, delta=0.1, weight=4)
#
#
#for (i in 1:4) {
#
#    if (i == 1) {
#        speciation_multiplier[i] <- 0.0
#    } else {
#        speciation_multiplier[i] ~ dnUniform(-2, 2)
#        speciation_multiplier[i].setValue(0.0)
#        moves[mvi++] = mvSlide(speciation_multiplier[i], delta=10.0, weight=4.0)
#        moves[mvi++] = mvSlide(speciation_multiplier[i], delta=1.0, weight=4.0)
#        moves[mvi++] = mvSlide(speciation_multiplier[i], delta=0.1, weight=4.0)
#    }
#    
#    turnover[i] ~ dnUniform(0, 2)
#    turnover[i].setValue(0.5)
#    moves[mvi++] = mvScale(turnover[i], lambda=10.0, weight=4.0)
#    moves[mvi++] = mvScale(turnover[i], lambda=2.0, weight=4.0)
#    moves[mvi++] = mvScale(turnover[i], lambda=0.1, weight=4.0)
#
#    speciation[i] := base_speciation * exp(speciation_multiplier[i])
#
#}
#
#extinction := speciation * turnover
#diversification := speciation - extinction

for (i in 1:4) {
    
    speciation[i] ~ dnExponential( speciation_pr )
    speciation[i].setValue(0.5)
    moves[mvi++] = mvScale(speciation[i], lambda=2.0, weight=4)
    moves[mvi++] = mvScale(speciation[i], lambda=1.0, weight=4)
    moves[mvi++] = mvScale(speciation[i], lambda=0.1, weight=4)
    
    extinction[i] ~ dnExponential( speciation_pr )
    extinction[i].setValue(0.4)
    moves[mvi++] = mvScale(extinction[i], lambda=2.0, weight=4)
    moves[mvi++] = mvScale(extinction[i], lambda=1.0, weight=4)
    moves[mvi++] = mvScale(extinction[i], lambda=0.1, weight=4)

    up_down_scale_mv[i] = mvUpDownScale(lambda=0.5, weight=8)
    up_down_scale_mv[i].addVariable( speciation[i], TRUE )
    up_down_scale_mv[i].addVariable( extinction[i], TRUE )
    moves[mvi++] = up_down_scale_mv[i]

}

diversification := speciation - extinction

# rate_matrix = [0A, 1A, 0B, 1B]
divers_0A := diversification[1]
divers_1A := diversification[2]
divers_0B := diversification[3]
divers_1B := diversification[4]

# transition rates among states
#num_events ~ dnUniform(1, 100)
#moves[mvi++] = mvScale(num_events, lambda=20, weight=5)
#moves[mvi++] = mvScale(num_events, lambda=2, weight=5)
num_events <- 2
rate_pr := psi.treeLength() / num_events

# between observed states
rate_01 <- 0.0 # no secondary gain of incompatibility
rate_10 ~ dnExponential( rate_pr )
Q := [rate_01, rate_10]

# between hidden states
rate_AB ~ dnExponential( rate_pr )
rate_BA ~ dnExponential( rate_pr )
R := [rate_AB, rate_BA]

# the rate matrix for the combined observed and hidden states 
rate_matrix := fnHiddenStateRateMatrix(Q, R, rescaled=false)
    
moves[mvi++] = mvScale(rate_10, lambda=1.0, weight=4.0)
moves[mvi++] = mvScale(rate_AB, lambda=1.0, weight=4.0)
moves[mvi++] = mvScale(rate_BA, lambda=1.0, weight=4.0)
moves[mvi++] = mvScale(rate_10, lambda=0.1, weight=4.0)
moves[mvi++] = mvScale(rate_AB, lambda=0.1, weight=4.0)
moves[mvi++] = mvScale(rate_BA, lambda=0.1, weight=4.0)


# root state frequencies 
root_states <- simplex( [0,1,0,0] ) # condition on starting in 1A
#root_states ~ dnDirichlet( rep(1, 4) )
#moves[mvi++] = mvBetaSimplex(root_states, weight=2)
#moves[mvi++] = mvDirichletSimplex(root_states, weight=2)



# rho is the probability of sampling species at the present
rho <- psi.ntips()/650

# character dependent birth death process
if (fixed_tree) {

    timetree ~ dnCDBDP( rootAge           = psi.rootAge(),
                        speciationRates   = speciation,
                        extinctionRates   = extinction, 
                        Q                 = rate_matrix, 
                        delta             = 1.0,
                        pi                = root_states,
                        rho               = rho,
                        condition         = "survival",
                        taxa              = taxa )

    #clamp the model with the observed tree and data
    timetree.clamp( psi )
    timetree.clampCharData( data_exp )

} else {
    
    timetree[1] ~ dnCDBDP( rootAge        = psi.rootAge(),
                        speciationRates   = speciation,
                        extinctionRates   = extinction, 
                        Q                 = rate_matrix, 
                        delta             = 1.0,
                        pi                = root_states,
                        rho               = rho,
                        condition         = "survival",
                        taxa              = taxa )

    #clamp the model with the observed tree and data
    timetree[1].clamp( psi )
    timetree[1].clampCharData( data_exp )
    
    for (i in 1:num_tree_samples) {

        j ~ dnUniformInteger(1, trees.size())
        timetree[i + 1] ~ dnCDBDP( rootAge    = trees[j].rootAge(),
                            speciationRates   = speciation,
                            extinctionRates   = extinction, 
                            Q                 = rate_matrix, 
                            delta             = 1.0,
                            pi                = root_states,
                            rho               = rho,
                            condition         = "survival",
                            taxa              = taxa )

        #clamp the model with the observed tree and data
        timetree[i + 1].clamp( trees[j] )
        timetree[i + 1].clampCharData( data_exp )

    }
}

#############
# The Model #
#############


### workspace model wrapper ###
mymodel = model(timetree)

# monitors
monitors[mni++] = mnScreen(printgen=sample_freq, speciation)
monitors[mni++] = mnModel(filename=base_dir + "output/selfing" + rep + ".log", printgen=sample_freq)
#monitors[mni++] = mnJointConditionalAncestralState(tree=timetree, cdbdp=timetree, type="NaturalNumbers", printgen=sample_freq, withTips=true, withStartStates=false, filename=base_dir + "output/anc_selfing.log")
if (fixed_tree) {
    monitors[mni++] = mnStochasticCharacterMap(cdbdp=timetree, printgen=sample_freq, filename=base_dir + "output/stochastic_selfing" + rep + ".log", include_simmap=true)
} else {
    monitors[mni++] = mnStochasticCharacterMap(cdbdp=timetree[1], printgen=sample_freq, filename=base_dir + "output/stochastic_selfing" + rep + ".log", include_simmap=true)
}

################
# The Analysis #
################

### workspace mcmc
mymcmc = mcmc(mymodel, monitors, moves)

### pre-burnin to tune the proposals
#mymcmc.burnin(generations=1000,tuningInterval=100)

### run the MCMC
mymcmc.run(generations=500)

q()

