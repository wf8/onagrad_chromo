
#
# ChromoSSE: Cladogenetic and Anagenetic Phylogenetic Models of Chromosome Number Evolution
# 
# Will Freyman, UC Berkeley
# freyman@berkeley.edu
# http://willfreyman.org
#
#
# This script specifies the ChromoSSE model and MCMC analysis.
#


# set an index for the MCMC moves
mi = 0


####### Chromosome Model


# We'll use exponential priors to model the rates of polyploidy and
# dysploidy events along the branches of the phylogeny

# calculate tree length
t_len = 0
for (i in 1:psi.nnodes()) {
    t_len = t_len + psi.branchLength(i)
}

ana_events ~ dnUniform(1, 50)
ana_events.setValue(10.0)
moves[mi++] = mvScale(ana_events, lambda=1.0, weight=20)
moves[mi++] = mvScale(ana_events, lambda=10.0, weight=20)

# calculate the inverse of the expected rate for 2 anagenetic events
# rate_pr := t_len / ana_events

rate_multipliers_prior <- rep(1, 4)
rate_multipliers ~ dnDirichlet(rate_multipliers_prior)
moves[mi++] = mvBetaSimplex(rate_multipliers, alpha=0.5, weight=5)
moves[mi++] = mvElementSwapSimplex(rate_multipliers, weight=5)

gamma_pr := t_len / (ana_events * rate_multipliers[1])
delta_pr := t_len / (ana_events * rate_multipliers[2])
rho_pr := t_len / (ana_events * rate_multipliers[3])
eta_pr := t_len / (ana_events * rate_multipliers[4])

# anagenetic rate of chromosome gains
gamma ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(gamma_pr), p=0.5)

# anagenetic rate of chromosome losses
delta ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(delta_pr), p=0.5)

# anagenetic rate of polyploidization
rho ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(rho_pr), p=0.5)

# anagenetic rate of demi-polyploidization
eta ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(eta_pr), p=0.5)

# linear component of rate of gain based on current number of chromosomes
gamma_l ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnUniform(-3/max_chromo, 3/max_chromo), p=0.5)
gamma_l.setValue(0.0)

# linear component of rate of losss based on current number of chromosomes
delta_l ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnUniform(-3/max_chromo, 3/max_chromo), p=0.5)
delta_l.setValue(0.0)

# Create the rate matrix for chromosome number transitions.
R := fnChromosomes(max_chromo, gamma, delta, rho, eta, gamma_l, delta_l)

root_frequencies_prior <- rep(1, max_chromo + 1)
root_frequencies ~ dnDirichlet(root_frequencies_prior)
moves[mi++] = mvBetaSimplex(root_frequencies, alpha=0.5, weight=10)
moves[mi++] = mvElementSwapSimplex(root_frequencies, weight=20)

# Add moves for each of the rates.
moves[mi++] = mvScale(gamma, lambda=1.0, weight=2)
moves[mi++] = mvScale(delta, lambda=1.0, weight=2)
moves[mi++] = mvScale(rho, lambda=1.0, weight=2)
moves[mi++] = mvScale(eta, lambda=1.0, weight=2)

moves[mi++] = mvSlide(gamma_l, delta=0.1, weight=1)
moves[mi++] = mvSlide(delta_l, delta=0.1, weight=1)
moves[mi++] = mvSlide(gamma_l, delta=0.001, weight=1)
moves[mi++] = mvSlide(delta_l, delta=0.001, weight=1)

moves[mi++] = mvRJSwitch(gamma, weight=2)
moves[mi++] = mvRJSwitch(delta, weight=2)
moves[mi++] = mvRJSwitch(rho, weight=2)
moves[mi++] = mvRJSwitch(eta, weight=2)
moves[mi++] = mvRJSwitch(gamma_l, weight=2)
moves[mi++] = mvRJSwitch(delta_l, weight=2)

# speciation rates for each cladogenetic event type

# expected num species at time t under constant birth-death is
# E(N_t) = N_0 e^{rt}
# therefore net diversification r is
# r = ( ln N_t - ln N_0 ) / t
# we use r as the mean for the speciation prior
taxa <- psi.taxa()
speciation_mean <- ln( taxa.size() ) / psi.rootAge()
speciation_pr <- 1 / speciation_mean

clado_no_change ~ dnExponential(speciation_pr)

clado_fission ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(speciation_pr), p=0.5)
clado_fusion ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(speciation_pr), p=0.5)
clado_polyploid ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(speciation_pr), p=0.5)
clado_demipoly ~ dnReversibleJumpMixture(constantValue=0.0, baseDistribution=dnExponential(speciation_pr), p=0.5)

clado_no_change.setValue(speciation_mean)
clado_fission.setValue(0.01)
clado_fusion.setValue(0.01)
clado_polyploid.setValue(0.01)
clado_demipoly.setValue(0.01)

# MCMC moves for speciation rates
moves[mi++] = mvScale(clado_no_change, lambda=5.0, weight=2)
moves[mi++] = mvScale(clado_fission, lambda=5.0, weight=2)
moves[mi++] = mvScale(clado_fusion, lambda=5.0, weight=2)
moves[mi++] = mvScale(clado_polyploid, lambda=5.0, weight=2)
moves[mi++] = mvScale(clado_demipoly, lambda=5.0, weight=2)

up_down_scale_mv = mvUpDownScale(lambda=0.5, weight=2)
up_down_scale_mv.addVariable( clado_no_change, TRUE )
up_down_scale_mv.addVariable( clado_fission, FALSE )
up_down_scale_mv.addVariable( clado_fusion, FALSE )
up_down_scale_mv.addVariable( clado_polyploid, FALSE )
up_down_scale_mv.addVariable( clado_demipoly, FALSE )
moves[mi++] = up_down_scale_mv

moves[mi++] = mvRJSwitch(clado_fission, weight=2)
moves[mi++] = mvRJSwitch(clado_fusion, weight=2)
moves[mi++] = mvRJSwitch(clado_polyploid, weight=2)
moves[mi++] = mvRJSwitch(clado_demipoly, weight=2)

# set a vector to hold the speciation rates
speciation_rates := [clado_no_change, clado_fission, clado_fusion, clado_polyploid, clado_demipoly]
total_speciation := sum(speciation_rates)

# map the speciation rates to chromosome cladogenetic events
clado_matrix := fnChromosomesCladoEventsBD(speciation_rates, max_chromo)

# a stochastic variable to represent the turnover. 
turnover ~ dnUniform(0, 1.0)
turnover.setValue(0.4)
moves[mi++] = mvScale(turnover, lambda=5.0, weight=3.0)

up_down_scale_mv2 = mvUpDownScale(lambda=0.5, weight=2)
up_down_scale_mv2.addVariable( clado_no_change, FALSE )
up_down_scale_mv2.addVariable( clado_fission, FALSE )
up_down_scale_mv2.addVariable( clado_fusion, FALSE )
up_down_scale_mv2.addVariable( clado_polyploid, FALSE )
up_down_scale_mv2.addVariable( clado_demipoly, FALSE )
up_down_scale_mv2.addVariable( turnover, FALSE )
moves[mi++] = up_down_scale_mv2

# make a vector of extinction rates for each state
for (i in 1:(max_chromo + 1)) {
    extinction[i] := turnover * total_speciation 
}

# construct a variable for the tree and chromosomes drawn from a 
# cladogenetic character state dependent birth death process
chromotree ~ dnCDCladoBDP( rootAge            = psi.rootAge(),
                    cladoEventMap             = clado_matrix,
                    extinctionRates           = extinction, 
                    Q                         = R,
                    delta                     = 1.0,
                    pi                        = root_frequencies,
                    rho                       = 1.0,
                    condition                 = "time",
                    taxa                      = taxa,
                    nTimeSlices               = n_time_slices )


# and clamp tree and the chromosome counts data
chromotree.clamp(psi)
chromotree.clampCharData(chromo_data)


### set up the monitors that will output parameter values to file and screen
monitors[1] = mnScreen(printgen=sample_freq, ana_events, gamma, gamma_l, delta, delta_l, rho, eta, clado_no_change, clado_fission, clado_fusion, clado_polyploid, clado_demipoly,turnover,total_speciation)
monitors[2] = mnModel(filename=base_dir + "output/chromosse" + rep + ".log", printgen=sample_freq)
monitors[3] = mnJointConditionalAncestralState(tree=psi, cdbdp=chromotree, type="NaturalNumbers", printgen=sample_freq, withTips=true, withStartStates=true, filename="output/chromosse-nodes-anc" + rep + ".log")
monitors[4] = mnJointConditionalCharacterMapping(cdbdp=chromotree, printgen=sample_freq, filename=base_dir + "output/chromosse-anc" + rep + ".log", include_simmap=true)

### finish model
mymodel = model(chromotree)

### workspace MCMC object ###
mymcmc = mcmc(mymodel, monitors, moves)

### run the MCMC ###
mymcmc.run(generations=mcmc_iterations)

### summarize ancestral states ###
#anc_states = readAncestralStateTrace("output/chromosse-anc.log")

# make summary tree
#ancestralStateTree(psi, anc_states, include_start_states=true, "output/ancestral_states_results.tree", burnin)

q()
